---
import Phrase from "@/components/audio/phrase.svelte"
import Word from "@/components/audio/word.svelte"
import BaseLayout from "@/layouts/base-layout.astro"
import { MarkdownInstance } from "astro"
import path from "node:path"

type Word = {
  en: string
  ja: string
  past?: string
}

interface Props {
  note: MarkdownInstance<{
    title: string
    sentence: string
    words: { [w in string]: string | Omit<Word, "en"> }[]
  }>
}

export async function getStaticPaths() {
  const notes = await Astro.glob("@/contents/**/*.mdx")

  return notes.map(note => {
    const filepath = note.file
    const segments = filepath.split("/")
    const rootIdx = segments.findIndex(seg => seg === "contents")
    const slugs = segments
      .slice(rootIdx + 1)
      .map(slug => path.basename(slug, ".mdx"))
    return {
      params: {
        sections:
          slugs[0] === "private" ? slugs.slice(1).join("/") : slugs.join("/"),
      },
      props: { note },
    }
  })
}

const { note } = Astro.props
const { frontmatter, Content } = note
const { sentence = "", words: _words = [] } = frontmatter

const words: Word[] = _words.map(word => {
  const [en] = Object.keys(word)
  const [info] = Object.values(word)
  if (typeof info === "string") {
    return { en, ja: info }
  }
  return { en, ...info }
})

const phrases = sentence.split("\n").map(str => {
  const _ja = str.match(/<ja>(.*)<\/ja>/)
  const ja = _ja ? _ja[1] : ""
  const en = str.replace(`<ja>${ja}</ja>`, "")
  return { ja, en }
})
---

<BaseLayout frontmatter={frontmatter}>
  <div>
    {
      phrases.map(({ en, ja }) =>
        en.length > 0 ? <Phrase client:load en={en} ja={ja} /> : <br />,
      )
    }
  </div>
  <div class="CardLayout">
    {words.map(word => <Word client:load word={word} />)}
  </div>
  <Content />
</BaseLayout>

<style>
  .CardLayout {
    display: grid;
    gap: 20px;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    padding: 2.5rem 0;
  }
</style>
